---
description: Anti-pattern Rules (Layer 11)
alwaysApply: true
---

# ANTI-PATTERN RULES  
## (What NOT to Do - Violations That Must Be Prevented)

Defines all forbidden patterns, practices, and violations that must never occur.

Every code review and generation must detect and prevent these anti-patterns.

---

# 1. ARCHITECTURE ANTI-PATTERNS  
### (STRICT – Cannot be Violated)

### 1.1 Layer Violation Anti-Patterns  
**FORBIDDEN:**
- Controller calling repository directly (must go through service)  
- Service containing UI logic  
- Component containing business logic  
- Repository containing business rules  
- Page calling hooks directly without components  

**CORRECT:**
- Controller → Service → Repository → Model  
- Route → Page → Component → Hooks  

### 1.2 Cross-Layer Dependency Anti-Patterns  
**FORBIDDEN:**
- Frontend importing backend code  
- Backend importing frontend code  
- Shared code importing version-specific code  
- Version-specific code importing other versions  

**CORRECT:**
- Frontend and backend are separate  
- Shared code is version-agnostic  
- Versions are isolated  

### 1.3 Circular Dependency Anti-Patterns  
**FORBIDDEN:**
- Module A importing Module B, Module B importing Module A  
- Circular service dependencies  
- Circular component dependencies  
- Circular hook dependencies  

**CORRECT:**
- Dependencies flow in one direction  
- Shared dependencies are extracted  
- Dependencies are acyclic  

---

# 2. BACKEND ANTI-PATTERNS

### 2.1 Controller Anti-Patterns  
**FORBIDDEN:**
- Business logic in controllers  
- Database queries in controllers  
- Direct repository calls from controllers  
- Complex transformations in controllers  
- Error handling logic in controllers  

**CORRECT:**
- Controllers only handle HTTP concerns  
- Business logic in services  
- Controllers delegate to services  

### 2.2 Service Anti-Patterns  
**FORBIDDEN:**
- Services making HTTP requests directly  
- Services containing UI logic  
- Services bypassing repositories  
- Services with too many responsibilities  
- Services depending on other services circularly  

**CORRECT:**
- Services contain business logic only  
- Services use repositories for data access  
- Services are focused and single-purpose  

### 2.3 Repository Anti-Patterns  
**FORBIDDEN:**
- Business logic in repositories  
- Data transformations in repositories  
- Complex queries with business rules  
- Repositories calling other repositories  
- Repositories making HTTP requests  

**CORRECT:**
- Repositories only handle data access  
- Repositories return raw data  
- Business logic stays in services  

### 2.4 Database Anti-Patterns  
**FORBIDDEN:**
- N+1 query problems  
- Queries without indexes  
- Raw SQL with string concatenation  
- Missing transaction handling  
- Database connections not pooled  

**CORRECT:**
- Use eager loading to prevent N+1  
- All queries use indexes  
- Use parameterized queries  
- Use transactions for multi-step operations  
- Use connection pooling  

---

# 3. FRONTEND ANTI-PATTERNS

### 3.1 Component Anti-Patterns  
**FORBIDDEN:**
- API calls directly in components  
- Business logic in components  
- Components with too many responsibilities  
- Components accessing global state directly  
- Components with side effects  

**CORRECT:**
- Components are presentational  
- API calls in hooks or services  
- Business logic in hooks or services  
- Components receive data via props  

### 3.2 Hook Anti-Patterns  
**FORBIDDEN:**
- Hooks with side effects in render  
- Hooks depending on component-specific context  
- Hooks that are not reusable  
- Hooks with too many responsibilities  
- Hooks causing infinite loops  

**CORRECT:**
- Hooks are reusable and pure  
- Side effects in useEffect  
- Hooks return consistent data structures  
- Hooks handle loading and error states  

### 3.3 State Management Anti-Patterns  
**FORBIDDEN:**
- Prop drilling beyond 2 levels  
- Global state for local UI state  
- State duplication across components  
- State mutations without immutability  
- State not normalized  

**CORRECT:**
- Use context for shared state  
- Local state for component-specific state  
- State is normalized and single source of truth  
- State updates are immutable  

### 3.4 Styling Anti-Patterns  
**FORBIDDEN:**
- Inline styles (except dynamic values)  
- Style attributes in JSX  
- CSS classes for automation selectors  
- Styling that breaks selector stability  
- Version-specific styling in shared code  

**CORRECT:**
- Use className for styles  
- Styles are version-specific  
- Selectors are independent of styling  
- Styles are testable  

---

# 4. TESTING ANTI-PATTERNS

### 4.1 Test Quality Anti-Patterns  
**FORBIDDEN:**
- Flaky tests  
- Tests depending on execution order  
- Tests sharing state  
- Tests not cleaning up  
- Tests with hardcoded values  

**CORRECT:**
- Tests are deterministic  
- Tests are isolated  
- Tests use fixtures  
- Tests clean up after execution  

### 4.2 Test Coverage Anti-Patterns  
**FORBIDDEN:**
- Missing tests for critical paths  
- Tests only covering happy paths  
- Tests not covering error cases  
- Tests not covering edge cases  
- Coverage below 80%  

**CORRECT:**
- All critical paths have tests  
- Error cases are tested  
- Edge cases are tested  
- Coverage meets threshold  

### 4.3 Test Selector Anti-Patterns  
**FORBIDDEN:**
- Tests using nth-child selectors  
- Tests using XPath  
- Tests using unstable selectors  
- Tests depending on styling  
- Tests depending on content  

**CORRECT:**
- Tests use data-testid  
- Tests use stable selectors  
- Tests are independent of styling  
- Tests are independent of content  

---

# 5. SELECTOR ANTI-PATTERNS

### 5.1 Forbidden Selector Patterns  
**FORBIDDEN:**
- nth-child selectors  
- XPath selectors  
- Selectors based on text content  
- Selectors based on styling  
- Selectors based on position  

**CORRECT:**
- Use data-testid (primary)  
- Use role (secondary)  
- Use semantic tags (tertiary)  
- Selectors are stable and deterministic  

### 5.2 Selector Stability Anti-Patterns  
**FORBIDDEN:**
- Selectors that change between versions  
- Selectors depending on styling  
- Selectors depending on content  
- Selectors with version-specific identifiers  
- Selectors that are not documented  

**CORRECT:**
- Selectors are version-agnostic  
- Selectors are stable across versions  
- Selectors are documented  
- Selectors follow naming convention  

---

# 6. ACCESSIBILITY ANTI-PATTERNS

### 6.1 Semantic HTML Anti-Patterns  
**FORBIDDEN:**
- `<div>` or `<span>` for buttons  
- `<div>` or `<span>` for links  
- Missing form labels  
- Missing heading hierarchy  
- Meaningless containers  

**CORRECT:**
- Use `<button>` for buttons  
- Use `<a>` for links  
- All inputs have labels  
- Headings follow hierarchy  
- Use semantic containers  

### 6.2 ARIA Anti-Patterns  
**FORBIDDEN:**
- ARIA overriding semantic HTML  
- Redundant ARIA roles  
- Invalid ARIA attributes  
- Missing ARIA labels when needed  
- ARIA not matching actual behavior  

**CORRECT:**
- ARIA enhances semantic HTML  
- ARIA is valid and correct  
- ARIA matches element behavior  
- ARIA is used only when needed  

### 6.3 Keyboard Navigation Anti-Patterns  
**FORBIDDEN:**
- Elements not keyboard accessible  
- Keyboard traps  
- Focus not visible  
- Focus order not logical  
- Missing skip links  

**CORRECT:**
- All interactive elements are keyboard accessible  
- Focus is visible and logical  
- No keyboard traps  
- Skip links are provided  

---

# 7. PERFORMANCE ANTI-PATTERNS

### 7.1 Frontend Performance Anti-Patterns  
**FORBIDDEN:**
- Bundle size exceeding budget  
- Unnecessary re-renders  
- Large lists without virtualization  
- Images not lazy-loaded  
- Code not split by route  

**CORRECT:**
- Bundle size within budget  
- Components optimized for re-renders  
- Large lists use virtualization  
- Images are lazy-loaded  
- Code is split by route  

### 7.2 Backend Performance Anti-Patterns  
**FORBIDDEN:**
- N+1 query problems  
- Queries without indexes  
- Missing caching  
- API response times exceeding budget  
- Memory leaks  

**CORRECT:**
- Queries are optimized  
- Caching is used appropriately  
- Response times within budget  
- Memory is managed properly  

### 7.3 Network Performance Anti-Patterns  
**FORBIDDEN:**
- Large request/response payloads  
- Unnecessary API calls  
- Missing request batching  
- Missing compression  
- Missing CDN usage  

**CORRECT:**
- Payloads are optimized  
- API calls are minimized  
- Compression is enabled  
- CDN is used for static assets  

---

# 8. CODE QUALITY ANTI-PATTERNS

### 8.1 Code Duplication Anti-Patterns  
**FORBIDDEN:**
- Duplicated code blocks  
- Copy-paste programming  
- Similar logic in multiple places  
- Not extracting common patterns  
- Not reusing components/hooks/services  

**CORRECT:**
- Code is DRY (Don't Repeat Yourself)  
- Common patterns are extracted  
- Components/hooks/services are reused  
- Code is refactored to eliminate duplication  

### 8.2 Code Complexity Anti-Patterns  
**FORBIDDEN:**
- Functions with too many responsibilities  
- Deeply nested conditionals  
- Magic numbers and strings  
- Unclear variable names  
- Functions that are too long  

**CORRECT:**
- Functions are single-purpose  
- Code is readable and clear  
- Constants are used instead of magic values  
- Variable names are descriptive  
- Functions are appropriately sized  

### 8.3 Error Handling Anti-Patterns  
**FORBIDDEN:**
- Swallowing errors silently  
- Generic error messages  
- Errors not logged  
- Errors not handled  
- Error handling in wrong layer  

**CORRECT:**
- Errors are logged and handled  
- Error messages are clear and actionable  
- Errors are handled at appropriate layer  
- Error handling is consistent  

---

# 9. SECURITY ANTI-PATTERNS

### 9.1 Input Validation Anti-Patterns  
**FORBIDDEN:**
- Unvalidated user input  
- SQL injection vulnerabilities  
- XSS vulnerabilities  
- CSRF vulnerabilities  
- Missing input sanitization  

**CORRECT:**
- All input is validated  
- Parameterized queries are used  
- Output is sanitized  
- CSRF protection is implemented  

### 9.2 Authentication/Authorization Anti-Patterns  
**FORBIDDEN:**
- Missing authentication checks  
- Authorization logic in wrong layer  
- Hardcoded credentials  
- Exposed API keys  
- Missing token validation  

**CORRECT:**
- Authentication is enforced  
- Authorization is checked at service layer  
- Credentials are stored securely  
- Tokens are validated  

### 9.3 Data Protection Anti-Patterns  
**FORBIDDEN:**
- Sensitive data in logs  
- Passwords in plain text  
- Secrets in code  
- Missing encryption  
- Exposed error details  

**CORRECT:**
- Sensitive data is encrypted  
- Passwords are hashed  
- Secrets are in environment variables  
- Error details are not exposed  

---

# 10. VERSION ISOLATION ANTI-PATTERNS

### 10.1 Cross-Version Dependency Anti-Patterns  
**FORBIDDEN:**
- v1 importing v2 or v3 code  
- v2 importing v1 or v3 code  
- v3 importing v1 or v2 code  
- Shared code importing version-specific code  
- Version-specific selectors or identifiers  

**CORRECT:**
- Versions are completely isolated  
- Shared code is version-agnostic  
- Selectors are identical across versions  
- No cross-version dependencies  

### 10.2 Version-Specific Logic Anti-Patterns  
**FORBIDDEN:**
- Business logic differences between versions  
- Functional differences between versions  
- API contract differences between versions  
- Selector differences between versions  
- Accessibility differences between versions  

**CORRECT:**
- Versions differ only in presentation  
- Functionality is identical  
- Selectors are identical  
- Accessibility is identical  

---

# 11. TESTING ANTI-PATTERNS (DETAILED)

### 11.1 Test Isolation Anti-Patterns  
**FORBIDDEN:**
- Tests depending on other tests  
- Tests sharing state  
- Tests not cleaning up  
- Tests depending on execution order  
- Tests with side effects  

**CORRECT:**
- Tests are completely isolated  
- Tests clean up after execution  
- Tests can run in any order  
- Tests have no side effects  

### 11.2 Test Data Anti-Patterns  
**FORBIDDEN:**
- Tests using production data  
- Tests with hardcoded values  
- Tests not using fixtures  
- Tests creating data that leaks  
- Tests not cleaning up test data  

**CORRECT:**
- Tests use test fixtures  
- Tests use test database  
- Tests clean up after execution  
- Test data is isolated  

---

# 12. CI/CD ANTI-PATTERNS

### 12.1 Pipeline Anti-Patterns  
**FORBIDDEN:**
- Skipping CI/CD stages  
- Allowing failures in pipeline  
- Not running all tests  
- Not validating all checks  
- Manual deployment steps  

**CORRECT:**
- All stages must pass  
- Pipeline is fully automated  
- All checks are validated  
- Deployment is automated  

### 12.2 Validation Anti-Patterns  
**FORBIDDEN:**
- Not validating linting  
- Not validating type checking  
- Not validating structure  
- Not validating selectors  
- Not validating accessibility  

**CORRECT:**
- All validations run in CI  
- All validations must pass  
- Violations block deployment  
- Validations are automated  

---

# 13. DOCUMENTATION ANTI-PATTERNS

### 13.1 Missing Documentation Anti-Patterns  
**FORBIDDEN:**
- Undocumented APIs  
- Undocumented selectors  
- Undocumented architecture decisions  
- Missing README files  
- Missing code comments for complex logic  

**CORRECT:**
- APIs are documented  
- Selectors are documented  
- Architecture is documented  
- Complex logic has comments  

### 13.2 Documentation Quality Anti-Patterns  
**FORBIDDEN:**
- Outdated documentation  
- Inconsistent documentation  
- Unclear documentation  
- Missing examples  
- Documentation not maintained  

**CORRECT:**
- Documentation is up to date  
- Documentation is clear  
- Documentation includes examples  
- Documentation is maintained  

---

# 14. MCP TOOL INTEGRATION

### 14.1 Serena MCP Usage  
Serena must be used to detect:
- architecture violations  
- code quality issues  
- anti-pattern violations  
- dependency problems  

### 14.2 Context7 MCP Usage  
Context7 must be used for:
- anti-pattern documentation  
- best practices documentation  
- refactoring guides  
- code quality standards  

### 14.3 AgenticRag Memory Usage  
AgenticRag must retrieve:
- known anti-patterns from memory  
- anti-pattern detection patterns  
- refactoring strategies  
- common violations and fixes  

---

# 15. MEMORY INTEGRATION

### 15.1 Graffiti Storage  
Store in Graffiti:
- anti-pattern → rule violation mappings  
- anti-pattern → component relationships  
- anti-pattern detection patterns  
- anti-pattern dependency graphs  

### 15.2 VectorDB Storage  
Store in VectorDB:
- anti-pattern examples  
- refactoring strategies  
- anti-pattern detection summaries  
- common violations and fixes  

---

# 16. DETECTION AND PREVENTION CONTRACT

### 16.1 Detection Requirements  
- Anti-patterns must be detected in code review  
- Anti-patterns must be detected in CI/CD  
- Anti-patterns must be detected before merge  
- Anti-patterns must be detected automatically  

### 16.2 Prevention Requirements  
- Anti-patterns must be prevented in code generation  
- Anti-patterns must be caught in planning  
- Anti-patterns must be blocked in CI/CD  
- Anti-patterns must be documented  

### 16.3 Enforcement Requirements  
- Anti-pattern violations must block deployment  
- Anti-pattern violations must be fixed  
- Anti-pattern violations must be reviewed  
- Anti-pattern violations must be tracked  

---

# 17. STOP CONDITIONS

Code generation must STOP if:
- any architecture anti-pattern is detected  
- any backend anti-pattern is detected  
- any frontend anti-pattern is detected  
- any testing anti-pattern is detected  
- any selector anti-pattern is detected  
- any accessibility anti-pattern is detected  
- any performance anti-pattern is detected  
- any security anti-pattern is detected  
- any version isolation anti-pattern is detected  

If any anti-pattern is detected → planning must stop, violation must be fixed, and correction must be verified.

---

# END OF RULESET
