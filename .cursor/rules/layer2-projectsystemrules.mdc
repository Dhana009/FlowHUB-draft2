---
description: Project System Rules (Layer 2)
alwaysApply: true
---

# PROJECT SYSTEM RULES  
## (Versioning, Unified Backend, Unified Testing, Documentation, Memory, Folder Structure)

Defines the system-wide contracts that govern how the project is organized and operates.

Every system-level decision must comply with these rules.

---

# 1. VERSIONING SYSTEM CONTRACT  
### (STRICT – Cannot be Violated)

The project implements **three versions (v1, v2, v3)** with strict isolation:

### 1.1 Version Definitions  
- **v1** = Bootstrap UI version  
- **v2** = Tailwind UI version  
- **v3** = Custom CSS UI version  

### 1.2 Version Isolation Principle  
- Each version maintains complete UI independence  
- Versions share backend, API, database, and testing infrastructure  
- Version-specific code must be isolated  
- No cross-version dependencies allowed  

### 1.3 Version Purpose  
- v1 demonstrates bootstrap + semantic correctness  
- v2 demonstrates utility-class consistency + automation stability  
- v3 demonstrates handwritten CSS + full semantic alignment  

Detailed versioning rules are defined in Layer 3.

---

# 2. UNIFIED BACKEND CONTRACT

### 2.1 Backend Unification Requirements  
- All versions share the same backend  
- Backend is version-agnostic  
- Backend provides unified API  
- Backend maintains single source of truth  

### 2.2 Backend Architecture  
- Backend follows 4-layer architecture (Layer 4)  
- Backend is independent of frontend versions  
- Backend API contracts are stable  
- Backend supports all frontend versions equally  

### 2.3 Backend Responsibilities  
- Business logic  
- Data persistence  
- API endpoints  
- Authentication and authorization  
- Data validation  

### 2.4 Backend Version Independence  
- Backend must not contain version-specific logic  
- Backend must not depend on frontend versions  
- Backend API must be version-agnostic  
- Backend must support all frontend versions  

---

# 3. UNIFIED TESTING CONTRACT

### 3.1 Testing Unification Requirements  
- All versions share the same testing infrastructure  
- Testing framework is unified  
- Test utilities are shared  
- Test patterns are consistent  

### 3.2 Testing Infrastructure  
- Unit testing framework (shared)  
- Integration testing framework (shared)  
- E2E testing framework (shared)  
- Test utilities and helpers (shared)  

### 3.3 Testing Coverage  
- Backend tests (shared across versions)  
- Frontend tests (version-specific but using shared framework)  
- Integration tests (shared)  
- E2E tests (run against all versions)  

### 3.4 Testing Consistency  
- Test structure is consistent  
- Test patterns are consistent  
- Test utilities are shared  
- Test execution is unified  

Detailed testing rules are defined in Layer 6.

---

# 4. DOCUMENTATION ARTIFACTS CONTRACT

### 4.1 Documentation Requirements  
- All documentation must be version-controlled  
- Documentation must be accessible  
- Documentation must be maintained  
- Documentation must be structured  

### 4.2 Documentation Types  
- PRDs (Product Requirements Documents)  
- FRDs (Functional Requirements Documents)  
- SLDs (System Design Documents)  
- API documentation  
- Architecture documentation  
- Test strategy documentation  

### 4.3 Documentation Standards  
- Documentation must be clear and concise  
- Documentation must be structured  
- Documentation must be versioned  
- Documentation must be accessible  

### 4.4 Documentation Maintenance  
- Documentation must be kept up to date  
- Documentation must be reviewed  
- Documentation must be version-controlled  
- Documentation must be searchable  

---

# 5. MEMORY SYSTEM CONTRACT

### 5.1 Memory System Overview  
The project uses two complementary memory systems:
- **Graffiti Graph** → structured, relational, rule-like knowledge  
- **VectorDB** → semantic, text-like, explanation and narrative knowledge  

Both are orchestrated via AgenticRag MCP.

### 5.2 Memory System Purpose  
- Store project structure and relationships (Graffiti)  
- Store examples and explanations (VectorDB)  
- Enable knowledge retrieval across sessions  
- Maintain project consistency  

### 5.3 Memory System Rules  
- Memory writes require explicit user approval  
- Memory retrieval is mandatory before planning/coding  
- Memory routing follows Layer 13 rules  
- Memory must be clean and structured  

Detailed memory rules are defined in `project-memory.mdc` and Layer 13.

---

# 6. PROJECT FOLDER STRUCTURE CONTRACT

### 6.1 Root Structure  
```
project-root/
  backend/          # Shared backend code
  src/
    v1/            # Bootstrap UI version
    v2/            # Tailwind UI version
    v3/            # Custom CSS UI version
    shared/        # Shared frontend code
  e2e/             # E2E tests
  docs/            # Documentation
  tests/           # Shared test utilities
```

### 6.2 Backend Structure  
- Backend follows Layer 4 folder structure  
- Backend is version-agnostic  
- Backend structure is unified  

### 6.3 Frontend Structure  
- Each version (v1, v2, v3) has its own folder  
- Shared frontend code in `src/shared/`  
- Version-specific code in `src/v[N]/`  
- Frontend structure follows Layer 5 rules  

### 6.4 Test Structure  
- Shared test utilities in `tests/`  
- E2E tests in `e2e/`  
- Version-specific tests co-located with code  
- Test structure follows Layer 6 rules  

### 6.5 Documentation Structure  
- Documentation in `docs/`  
- Documentation organized by type  
- Documentation version-controlled  
- Documentation accessible  

---

# 7. CODE STABILITY CONTRACT

### 7.1 Stability Requirements  
- Code must be stable and predictable  
- Code changes must be minimal and focused  
- Code must not break existing functionality  
- Code must maintain backward compatibility when possible  

### 7.2 Stability Rules  
- Changes must be incremental  
- Changes must be tested  
- Changes must be documented  
- Changes must be reviewed  

### 7.3 Stability Enforcement  
- Automated tests must pass  
- Code reviews must be performed  
- Stability must be validated  
- Stability must be maintained  

### 7.4 Stability Monitoring  
- Code stability must be monitored  
- Stability regressions must be detected  
- Stability issues must be addressed  
- Stability must be reported  

---

# 8. SYSTEM INTEGRATION CONTRACT

### 8.1 Integration Requirements  
- All system components must integrate correctly  
- Integration must be tested  
- Integration must be documented  
- Integration must be maintained  

### 8.2 Component Integration  
- Frontend ↔ Backend via API  
- Versions ↔ Backend via unified API  
- Tests ↔ Code via shared framework  
- Documentation ↔ Code via version control  

### 8.3 Integration Testing  
- Integration must be tested  
- Integration tests must pass  
- Integration must be validated  
- Integration must be monitored  

---

# 9. SYSTEM CONFIGURATION CONTRACT

### 9.1 Configuration Requirements  
- Configuration must be version-controlled  
- Configuration must be environment-specific  
- Configuration must be documented  
- Configuration must be validated  

### 9.2 Configuration Management  
- Environment variables for secrets  
- Configuration files for settings  
- Configuration must be validated  
- Configuration must be secure  

### 9.3 Configuration Consistency  
- Configuration must be consistent across environments  
- Configuration must be validated  
- Configuration must be documented  
- Configuration must be maintained  

---

# 10. SYSTEM DEPLOYMENT CONTRACT

### 10.1 Deployment Requirements  
- Deployment must be automated  
- Deployment must be repeatable  
- Deployment must be tested  
- Deployment must be monitored  

### 10.2 Deployment Process  
- All versions deploy from same backend  
- Each version deploys independently  
- Deployment must be consistent  
- Deployment must be documented  

### 10.3 Deployment Validation  
- Deployment must be validated  
- Health checks must pass  
- Deployment must be monitored  
- Deployment must be reversible  

---

# 11. MCP TOOL INTEGRATION

### 11.1 MCP Tool Requirements  
- MCP tools must be integrated  
- MCP tools must be used correctly  
- MCP tools must be available  
- MCP tool usage must follow Layer 15 rules  

### 11.2 MCP Tool Usage  
- Context7 for documentation  
- AgenticRag for memory  
- Serena for code operations  
- BraveSearch/PerplexitySearch for research  

Detailed MCP rules are defined in Layer 15.

---

# 12. MEMORY INTEGRATION

### 12.1 Graffiti Storage  
Store in Graffiti:
- system → version mappings  
- system → component relationships  
- system → configuration mappings  
- system dependency graphs  

### 12.2 VectorDB Storage  
Store in VectorDB:
- system configuration examples  
- deployment strategies  
- system troubleshooting guides  
- system best practices  

---

# 13. STOP CONDITIONS

System-level implementation must STOP if:
- version isolation is violated  
- backend contains version-specific logic  
- testing infrastructure is not unified  
- documentation is not maintained  
- memory system is not used correctly  
- folder structure is violated  
- code stability is compromised  
- system integration is broken  

If any violation is detected → planning must stop and correction must be proposed.

---

# END OF RULESET
